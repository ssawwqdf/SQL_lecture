/*-------------------------
CH 11. VIEW SEQUENCE INDEX
-------------------------*/


--<뷰>
CREATE VIEW ED_VIEW1 --단일뷰(테이블 하나가 이용됨)
AS (SELECT * FROM EMP);

CREATE VIEW ED_VIEW2 --복합뷰(테이블 여러개가 이용됨)
AS (SELECT E.ENAME, E.EMPNO, D.DNAME, D.DEPTNO
    FROM EMP E, DEPT D
    WHERE E.DEPTNO=D.DEPTNO);
    
DROP VIEW ED_VIEW22;

UPDATE ED_VIEW2
SET ENAME='SMITH99'
WHERE ENAME='SMITH'; --뷰에서도 데이터 수정 가능 -> 원본 것도 바뀐다!!



--<시퀀스==번호표>
DROP SEQUENCE MY_SEQ;

CREATE SEQUENCE MY_SEQ2
START WITH 1
INCREMENT BY 1; --MIN, START 안 정하면 1
                    --MAX 안 적으면 SQL이 계산가능한 최대값(강사님은아직다채운거못보셨다)
                    --NO CACHE
                    
SELECT MY_SEQ2.CURRVAL FROM DUAL; --현재 SEQ 보여준다.
SELECT MY_SEQ2.NEXTVAL FROM DUAL; --NEXT SEQ를 보여주면서 실행한다.

CREATE TABLE UU(NUM NUMBER, USERID VARCHAR2(20)); --UID라쓰면 오라클 함수라 에러난다
INSERT INTO UU VALUES(1,'KIM');  
INSERT INTO UU VALUES(MY_SEQ2.NEXTVAL,'KIM'); --SEQ를 넣어줄 수도 있다.
SELECT * FROM UU;  --번호표가 순서대로 나오지 않을 수도 있다.

CREATE TABLE UU2(NUM NUMBER, USERID VARCHAR2(20)); --UID라쓰면 오라클 함수라 에러난다
INSERT INTO UU2 VALUES(MY_SEQ2.NEXTVAL,'KIM'); --하나의 번호표기계를 이용해 두 테이블에 넣는다.
SELECT * FROM UU;

--테이블마다 번호표 따로 만드는 경우

CREATE SEQUENCE MS1
START WITH 1
INCREMENT BY 1;

CREATE SEQUENCE MS2
START WITH 1
INCREMENT BY 2;

CREATE TABLE TT1(NUM NUMBER, USERID VARCHAR2(20));
INSERT INTO TT1 VALUES(MS1.NEXTVAL,'KIM');
SELECT * FROM TT1;

CREATE TABLE TT2(NUM NUMBER, USERID VARCHAR2(20));
INSERT INTO TT2 VALUES(MS2.NEXTVAL,'KIM');
SELECT * FROM TT2;

--<INDEX> --검색 빠르게 하려고
DROP INDEX INX_EMP_NM;

CREATE INDEX IDX_EMP_NM ON EMP(ENAME); -- 단일인덱스

CREATE INDEX IDX_EMP_NM_JOB
    ON EMP (ENAME, JOB);  --복합인덱스 **순서 중요하다.

SELECT * FROM EMP
WHERE ENAME = 'ALLEN' AND JOB='ASLESMAN';


--인덱스와 속도
--HIREDATE에 인덱스를 추가했다고 하자.

SELECT *
FROM EMP
WHERE HIREDATE BETWEEN '1980-01-01' AND '1980-12-31'; --빠르다. 인덱스 덕분

SELECT *
FROM EMP
WHERE TO_CHAR(HIREDATE, 'YYYY') = '1980' ; --느리다. 조건절에서 원본데이터에 가하면 INDEX안 먹음

SELECT *
FROM EMP
WHERE ENAME LIKE '%LL%'; --느리다. LIKE의 경우 인덱스를 타지 않는다.

--잦은 변경이나 삭제가 있는 테이블에는 인덱스 많이 생성하면 지연...


--(HIREDATE에 인덱스 쓴 경우) INLINE VIEW를 쓰면 INDEX 영향 안 받나?
--그래도 받는다.
SELECT *
FROM (SELECT *
        FROM EMP
        WHERE DEPTNO=10)
WHERE HIREDATE BETWEEN '1980-01-01' AND '1980-12-31';