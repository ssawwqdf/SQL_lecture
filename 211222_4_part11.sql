/*-------------------------
CH 11. VIEW SEQUENCE INDEX
-------------------------*/


--<뷰>
CREATE VIEW ED_VIEW1 --단일뷰(테이블 하나가 이용됨)
AS (SELECT * FROM EMP);

CREATE VIEW ED_VIEW2 --복합뷰(테이블 여러개가 이용됨)
AS (SELECT E.ENAME, E.EMPNO, D.DNAME, D.DEPTNO
    FROM EMP E, DEPT D
    WHERE E.DEPTNO=D.DEPTNO);
    
DROP VIEW ED_VIEW22;

UPDATE ED_VIEW2
SET ENAME='SMITH99'
WHERE ENAME='SMITH'; --뷰에서도 데이터 수정 가능 -> 원본 것도 바뀐다!!



--<시퀀스==번호표>
DROP SEQUENCE MY_SEQ;

CREATE SEQUENCE MY_SEQ2
START WITH 1
INCREMENT BY 1; --MIN, START 안 정하면 1
                    --MAX 안 적으면 SQL이 계산가능한 최대값(강사님은아직다채운거못보셨다)
                    --NO CACHE
                    
SELECT MY_SEQ2.CURRVAL FROM DUAL; --현재 SEQ 보여준다.
SELECT MY_SEQ2.NEXTVAL FROM DUAL; --NEXT SEQ를 보여주면서 실행한다.

CREATE TABLE UU(NUM NUMBER, USERID VARCHAR2(20)); --UID라쓰면 오라클 함수라 에러난다
INSERT INTO UU VALUES(1,'KIM');  
INSERT INTO UU VALUES(MY_SEQ2.NEXTVAL,'KIM'); --SEQ를 넣어줄 수도 있다.
SELECT * FROM UU;  --번호표가 순서대로 나오지 않을 수도 있다.

CREATE TABLE UU2(NUM NUMBER, USERID VARCHAR2(20)); --UID라쓰면 오라클 함수라 에러난다
INSERT INTO UU2 VALUES(MY_SEQ2.NEXTVAL,'KIM'); --하나의 번호표기계를 이용해 두 테이블에 넣는다.
SELECT * FROM UU;

--테이블마다 번호표 따로 만드는 경우

CREATE SEQUENCE MS1
START WITH 1
INCREMENT BY 1;

CREATE SEQUENCE MS2
START WITH 1
INCREMENT BY 2;

CREATE TABLE TT1(NUM NUMBER, USERID VARCHAR2(20));
INSERT INTO TT1 VALUES(MS1.NEXTVAL,'KIM');
SELECT * FROM TT1;

CREATE TABLE TT2(NUM NUMBER, USERID VARCHAR2(20));
INSERT INTO TT2 VALUES(MS2.NEXTVAL,'KIM');
SELECT * FROM TT2;

--<INDEX> --검색 빠르게 하려고
DROP INDEX INX_EMP_NM;

CREATE INDEX IDX_EMP_NM ON EMP(ENAME);